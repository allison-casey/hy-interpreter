["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/codemirror/mode/clojure/clojure.js"],"~:js","shadow$provide.module$node_modules$codemirror$mode$clojure$clojure=function(global,require,module,exports){(function(mod){\"object\"===typeof exports&&\"object\"===typeof module?mod(require(\"module$node_modules$codemirror$lib$codemirror\")):\"function\"===typeof define&&define.amd?define([\"../../lib/codemirror\"],mod):mod(CodeMirror)})(function(CodeMirror){CodeMirror.defineMode(\"clojure\",function(options){function base(stream,state){if(stream.eatSpace()||stream.eat(\",\"))return[\"space\",null];if(stream.match(numberLiteral))return[null,\n\"number\"];if(stream.match(characterLiteral))return[null,\"string-2\"];if(stream.eat(/^\"/))return(state.tokenize=inString)(stream,state);if(stream.eat(/^[(\\[{]/))return[\"open\",\"bracket\"];if(stream.eat(/^[)\\]}]/))return[\"close\",\"bracket\"];if(stream.eat(/^;/))return stream.skipToEnd(),[\"space\",\"comment\"];if(stream.eat(/^[#'@^`~]/))return[null,\"meta\"];var matches=stream.match(qualifiedSymbol);matches=matches&&matches[0];return matches?\"comment\"===matches&&\"(\"===state.lastToken?(state.tokenize=inComment)(stream,\nstate):is(matches,atom)||\":\"===matches.charAt(0)?[\"symbol\",\"atom\"]:is(matches,specialForm)||is(matches,coreSymbol)?[\"symbol\",\"keyword\"]:\"(\"===state.lastToken?[\"symbol\",\"builtin\"]:[\"symbol\",\"variable\"]:(stream.next(),stream.eatWhile(function(c){return!is(c,delimiter)}),[null,\"error\"])}function inString(stream,state){for(var escaped=!1,next;next=stream.next();){if('\"'===next&&!escaped){state.tokenize=base;break}escaped=!escaped&&\"\\\\\"===next}return[null,\"string\"]}function inComment(stream,state){for(var parenthesisCount=\n1,next;next=stream.next();)if(\")\"===next&&parenthesisCount--,\"(\"===next&&parenthesisCount++,0===parenthesisCount){stream.backUp(1);state.tokenize=base;break}return[\"space\",\"comment\"]}function createLookupMap(words){for(var obj={},i=0;i<words.length;++i)obj[words[i]]=!0;return obj}function is(value,test){if(test instanceof RegExp)return test.test(value);if(test instanceof Object)return test.propertyIsEnumerable(value)}var atoms=[\"false\",\"nil\",\"true\"],specialForms=\". catch def do if monitor-enter monitor-exit new quote recur set! throw try var\".split(\" \"),\ncoreSymbols=\"* *' *1 *2 *3 *agent* *allow-unresolved-vars* *assert* *clojure-version* *command-line-args* *compile-files* *compile-path* *compiler-options* *data-readers* *default-data-reader-fn* *e *err* *file* *flush-on-newline* *fn-loader* *in* *math-context* *ns* *out* *print-dup* *print-length* *print-level* *print-meta* *print-namespace-maps* *print-readably* *read-eval* *reader-resolver* *source-path* *suppress-read* *unchecked-math* *use-context-classloader* *verbose-defrecords* *warn-on-reflection* + +' - -' -\\x3e -\\x3e\\x3e -\\x3eArrayChunk -\\x3eEduction -\\x3eVec -\\x3eVecNode -\\x3eVecSeq -cache-protocol-fn -reset-methods .. / \\x3c \\x3c\\x3d \\x3d \\x3d\\x3d \\x3e \\x3e\\x3d EMPTY-NODE Inst StackTraceElement-\\x3evec Throwable-\\x3emap accessor aclone add-classpath add-watch agent agent-error agent-errors aget alength alias all-ns alter alter-meta! alter-var-root amap ancestors and any? apply areduce array-map as-\\x3e aset aset-boolean aset-byte aset-char aset-double aset-float aset-int aset-long aset-short assert assoc assoc! assoc-in associative? atom await await-for await1 bases bean bigdec bigint biginteger binding bit-and bit-and-not bit-clear bit-flip bit-not bit-or bit-set bit-shift-left bit-shift-right bit-test bit-xor boolean boolean-array boolean? booleans bound-fn bound-fn* bound? bounded-count butlast byte byte-array bytes bytes? case cast cat char char-array char-escape-string char-name-string char? chars chunk chunk-append chunk-buffer chunk-cons chunk-first chunk-next chunk-rest chunked-seq? class class? clear-agent-errors clojure-version coll? comment commute comp comparator compare compare-and-set! compile complement completing concat cond cond-\\x3e cond-\\x3e\\x3e condp conj conj! cons constantly construct-proxy contains? count counted? create-ns create-struct cycle dec dec' decimal? declare dedupe default-data-readers definline definterface defmacro defmethod defmulti defn defn- defonce defprotocol defrecord defstruct deftype delay delay? deliver denominator deref derive descendants destructure disj disj! dissoc dissoc! distinct distinct? doall dorun doseq dosync dotimes doto double double-array double? doubles drop drop-last drop-while eduction empty empty? ensure ensure-reduced enumeration-seq error-handler error-mode eval even? every-pred every? ex-data ex-info extend extend-protocol extend-type extenders extends? false? ffirst file-seq filter filterv find find-keyword find-ns find-protocol-impl find-protocol-method find-var first flatten float float-array float? floats flush fn fn? fnext fnil for force format frequencies future future-call future-cancel future-cancelled? future-done? future? gen-class gen-interface gensym get get-in get-method get-proxy-class get-thread-bindings get-validator group-by halt-when hash hash-combine hash-map hash-ordered-coll hash-set hash-unordered-coll ident? identical? identity if-let if-not if-some ifn? import in-ns inc inc' indexed? init-proxy inst-ms inst-ms* inst? instance? int int-array int? integer? interleave intern interpose into into-array ints io! isa? iterate iterator-seq juxt keep keep-indexed key keys keyword keyword? last lazy-cat lazy-seq let letfn line-seq list list* list? load load-file load-reader load-string loaded-libs locking long long-array longs loop macroexpand macroexpand-1 make-array make-hierarchy map map-entry? map-indexed map? mapcat mapv max max-key memfn memoize merge merge-with meta method-sig methods min min-key mix-collection-hash mod munge name namespace namespace-munge nat-int? neg-int? neg? newline next nfirst nil? nnext not not-any? not-empty not-every? not\\x3d ns ns-aliases ns-imports ns-interns ns-map ns-name ns-publics ns-refers ns-resolve ns-unalias ns-unmap nth nthnext nthrest num number? numerator object-array odd? or parents partial partition partition-all partition-by pcalls peek persistent! pmap pop pop! pop-thread-bindings pos-int? pos? pr pr-str prefer-method prefers primitives-classnames print print-ctor print-dup print-method print-simple print-str printf println println-str prn prn-str promise proxy proxy-call-with-super proxy-mappings proxy-name proxy-super push-thread-bindings pvalues qualified-ident? qualified-keyword? qualified-symbol? quot rand rand-int rand-nth random-sample range ratio? rational? rationalize re-find re-groups re-matcher re-matches re-pattern re-seq read read-line read-string reader-conditional reader-conditional? realized? record? reduce reduce-kv reduced reduced? reductions ref ref-history-count ref-max-history ref-min-history ref-set refer refer-clojure reify release-pending-sends rem remove remove-all-methods remove-method remove-ns remove-watch repeat repeatedly replace replicate require reset! reset-meta! reset-vals! resolve rest restart-agent resultset-seq reverse reversible? rseq rsubseq run! satisfies? second select-keys send send-off send-via seq seq? seqable? seque sequence sequential? set set-agent-send-executor! set-agent-send-off-executor! set-error-handler! set-error-mode! set-validator! set? short short-array shorts shuffle shutdown-agents simple-ident? simple-keyword? simple-symbol? slurp some some-\\x3e some-\\x3e\\x3e some-fn some? sort sort-by sorted-map sorted-map-by sorted-set sorted-set-by sorted? special-symbol? spit split-at split-with str string? struct struct-map subs subseq subvec supers swap! swap-vals! symbol symbol? sync tagged-literal tagged-literal? take take-last take-nth take-while test the-ns thread-bound? time to-array to-array-2d trampoline transduce transient tree-seq true? type unchecked-add unchecked-add-int unchecked-byte unchecked-char unchecked-dec unchecked-dec-int unchecked-divide-int unchecked-double unchecked-float unchecked-inc unchecked-inc-int unchecked-int unchecked-long unchecked-multiply unchecked-multiply-int unchecked-negate unchecked-negate-int unchecked-remainder-int unchecked-short unchecked-subtract unchecked-subtract-int underive unquote unquote-splicing unreduced unsigned-bit-shift-right update update-in update-proxy uri? use uuid? val vals var-get var-set var? vary-meta vec vector vector-of vector? volatile! volatile? vreset! vswap! when when-first when-let when-not when-some while with-bindings with-bindings* with-in-str with-loading-context with-local-vars with-meta with-open with-out-str with-precision with-redefs with-redefs-fn xml-seq zero? zipmap\".split(\" \");\nCodeMirror.registerHelper(\"hintWords\",\"clojure\",[].concat(atoms,specialForms,coreSymbols));var atom=createLookupMap(atoms),specialForm=createLookupMap(specialForms),coreSymbol=createLookupMap(coreSymbols),hasBodyParameter=createLookupMap(\"-\\x3e -\\x3e\\x3e as-\\x3e binding bound-fn case catch comment cond cond-\\x3e cond-\\x3e\\x3e condp def definterface defmethod defn defmacro defprotocol defrecord defstruct deftype do doseq dotimes doto extend extend-protocol extend-type fn for future if if-let if-not if-some let letfn locking loop ns proxy reify struct-map some-\\x3e some-\\x3e\\x3e try when when-first when-let when-not when-some while with-bindings with-bindings* with-in-str with-loading-context with-local-vars with-meta with-open with-out-str with-precision with-redefs with-redefs-fn\".split(\" \")),\ndelimiter=/^(?:[\\\\\\[\\]\\s\"(),;@^`{}~]|$)/,numberLiteral=/^(?:[+\\-]?\\d+(?:(?:N|(?:[eE][+\\-]?\\d+))|(?:\\.?\\d*(?:M|(?:[eE][+\\-]?\\d+))?)|\\/\\d+|[xX][0-9a-fA-F]+|r[0-9a-zA-Z]+)?(?=[\\\\\\[\\]\\s\"#'(),;@^`{}~]|$))/,characterLiteral=/^(?:\\\\(?:backspace|formfeed|newline|return|space|tab|o[0-7]{3}|u[0-9A-Fa-f]{4}|x[0-9A-Fa-f]{4}|.)?(?=[\\\\\\[\\]\\s\"(),;@^`{}~]|$))/,qualifiedSymbol=/^(?:(?:[^\\\\\\/\\[\\]\\d\\s\"#'(),;@^`{}~][^\\\\\\[\\]\\s\"(),;@^`{}~]*(?:\\.[^\\\\\\/\\[\\]\\d\\s\"#'(),;@^`{}~][^\\\\\\[\\]\\s\"(),;@^`{}~]*)*\\/)?(?:\\/|[^\\\\\\/\\[\\]\\d\\s\"#'(),;@^`{}~][^\\\\\\[\\]\\s\"(),;@^`{}~]*)*(?=[\\\\\\[\\]\\s\"(),;@^`{}~]|$))/;\nreturn{startState:function(){return{ctx:{prev:null,start:0,indentTo:0},lastToken:null,tokenize:base}},token:function(stream,state){stream.sol()&&\"number\"!==typeof state.ctx.indentTo&&(state.ctx.indentTo=state.ctx.start+1);var typeStylePair=state.tokenize(stream,state),type=typeStylePair[0];typeStylePair=typeStylePair[1];var current=stream.current();\"space\"!==type&&(\"(\"===state.lastToken&&null===state.ctx.indentTo?\"symbol\"===type&&is(current,hasBodyParameter)?state.ctx.indentTo=state.ctx.start+options.indentUnit:\nstate.ctx.indentTo=\"next\":\"next\"===state.ctx.indentTo&&(state.ctx.indentTo=stream.column()),state.lastToken=current);\"open\"===type?state.ctx={prev:state.ctx,start:stream.column(),indentTo:null}:\"close\"===type&&(state.ctx=state.ctx.prev||state.ctx);return typeStylePair},indent:function(state){var i=state.ctx.indentTo;return\"number\"===typeof i?i:state.ctx.start+1},closeBrackets:{pairs:'()[]{}\"\"'},lineComment:\";;\"}});CodeMirror.defineMIME(\"text/x-clojure\",\"clojure\");CodeMirror.defineMIME(\"text/x-clojurescript\",\n\"clojure\");CodeMirror.defineMIME(\"application/edn\",\"clojure\")})}","~:source","shadow$provide[\"module$node_modules$codemirror$mode$clojure$clojure\"] = function(global,require,module,exports) {\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports === \"object\" && typeof module === \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define === \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"clojure\", function (options) {\n  var atoms = [\"false\", \"nil\", \"true\"];\n  var specialForms = [\".\", \"catch\", \"def\", \"do\", \"if\", \"monitor-enter\",\n      \"monitor-exit\", \"new\", \"quote\", \"recur\", \"set!\", \"throw\", \"try\", \"var\"];\n  var coreSymbols = [\"*\", \"*'\", \"*1\", \"*2\", \"*3\", \"*agent*\",\n      \"*allow-unresolved-vars*\", \"*assert*\", \"*clojure-version*\",\n      \"*command-line-args*\", \"*compile-files*\", \"*compile-path*\",\n      \"*compiler-options*\", \"*data-readers*\", \"*default-data-reader-fn*\", \"*e\",\n      \"*err*\", \"*file*\", \"*flush-on-newline*\", \"*fn-loader*\", \"*in*\",\n      \"*math-context*\", \"*ns*\", \"*out*\", \"*print-dup*\", \"*print-length*\",\n      \"*print-level*\", \"*print-meta*\", \"*print-namespace-maps*\",\n      \"*print-readably*\", \"*read-eval*\", \"*reader-resolver*\", \"*source-path*\",\n      \"*suppress-read*\", \"*unchecked-math*\", \"*use-context-classloader*\",\n      \"*verbose-defrecords*\", \"*warn-on-reflection*\", \"+\", \"+'\", \"-\", \"-'\",\n      \"->\", \"->>\", \"->ArrayChunk\", \"->Eduction\", \"->Vec\", \"->VecNode\",\n      \"->VecSeq\", \"-cache-protocol-fn\", \"-reset-methods\", \"..\", \"/\", \"<\", \"<=\",\n      \"=\", \"==\", \">\", \">=\", \"EMPTY-NODE\", \"Inst\", \"StackTraceElement->vec\",\n      \"Throwable->map\", \"accessor\", \"aclone\", \"add-classpath\", \"add-watch\",\n      \"agent\", \"agent-error\", \"agent-errors\", \"aget\", \"alength\", \"alias\",\n      \"all-ns\", \"alter\", \"alter-meta!\", \"alter-var-root\", \"amap\", \"ancestors\",\n      \"and\", \"any?\", \"apply\", \"areduce\", \"array-map\", \"as->\", \"aset\",\n      \"aset-boolean\", \"aset-byte\", \"aset-char\", \"aset-double\", \"aset-float\",\n      \"aset-int\", \"aset-long\", \"aset-short\", \"assert\", \"assoc\", \"assoc!\",\n      \"assoc-in\", \"associative?\", \"atom\", \"await\", \"await-for\", \"await1\",\n      \"bases\", \"bean\", \"bigdec\", \"bigint\", \"biginteger\", \"binding\", \"bit-and\",\n      \"bit-and-not\", \"bit-clear\", \"bit-flip\", \"bit-not\", \"bit-or\", \"bit-set\",\n      \"bit-shift-left\", \"bit-shift-right\", \"bit-test\", \"bit-xor\", \"boolean\",\n      \"boolean-array\", \"boolean?\", \"booleans\", \"bound-fn\", \"bound-fn*\",\n      \"bound?\", \"bounded-count\", \"butlast\", \"byte\", \"byte-array\", \"bytes\",\n      \"bytes?\", \"case\", \"cast\", \"cat\", \"char\", \"char-array\",\n      \"char-escape-string\", \"char-name-string\", \"char?\", \"chars\", \"chunk\",\n      \"chunk-append\", \"chunk-buffer\", \"chunk-cons\", \"chunk-first\", \"chunk-next\",\n      \"chunk-rest\", \"chunked-seq?\", \"class\", \"class?\", \"clear-agent-errors\",\n      \"clojure-version\", \"coll?\", \"comment\", \"commute\", \"comp\", \"comparator\",\n      \"compare\", \"compare-and-set!\", \"compile\", \"complement\", \"completing\",\n      \"concat\", \"cond\", \"cond->\", \"cond->>\", \"condp\", \"conj\", \"conj!\", \"cons\",\n      \"constantly\", \"construct-proxy\", \"contains?\", \"count\", \"counted?\",\n      \"create-ns\", \"create-struct\", \"cycle\", \"dec\", \"dec'\", \"decimal?\",\n      \"declare\", \"dedupe\", \"default-data-readers\", \"definline\", \"definterface\",\n      \"defmacro\", \"defmethod\", \"defmulti\", \"defn\", \"defn-\", \"defonce\",\n      \"defprotocol\", \"defrecord\", \"defstruct\", \"deftype\", \"delay\", \"delay?\",\n      \"deliver\", \"denominator\", \"deref\", \"derive\", \"descendants\", \"destructure\",\n      \"disj\", \"disj!\", \"dissoc\", \"dissoc!\", \"distinct\", \"distinct?\", \"doall\",\n      \"dorun\", \"doseq\", \"dosync\", \"dotimes\", \"doto\", \"double\", \"double-array\",\n      \"double?\", \"doubles\", \"drop\", \"drop-last\", \"drop-while\", \"eduction\",\n      \"empty\", \"empty?\", \"ensure\", \"ensure-reduced\", \"enumeration-seq\",\n      \"error-handler\", \"error-mode\", \"eval\", \"even?\", \"every-pred\", \"every?\",\n      \"ex-data\", \"ex-info\", \"extend\", \"extend-protocol\", \"extend-type\",\n      \"extenders\", \"extends?\", \"false?\", \"ffirst\", \"file-seq\", \"filter\",\n      \"filterv\", \"find\", \"find-keyword\", \"find-ns\", \"find-protocol-impl\",\n      \"find-protocol-method\", \"find-var\", \"first\", \"flatten\", \"float\",\n      \"float-array\", \"float?\", \"floats\", \"flush\", \"fn\", \"fn?\", \"fnext\", \"fnil\",\n      \"for\", \"force\", \"format\", \"frequencies\", \"future\", \"future-call\",\n      \"future-cancel\", \"future-cancelled?\", \"future-done?\", \"future?\",\n      \"gen-class\", \"gen-interface\", \"gensym\", \"get\", \"get-in\", \"get-method\",\n      \"get-proxy-class\", \"get-thread-bindings\", \"get-validator\", \"group-by\",\n      \"halt-when\", \"hash\", \"hash-combine\", \"hash-map\", \"hash-ordered-coll\",\n      \"hash-set\", \"hash-unordered-coll\", \"ident?\", \"identical?\", \"identity\",\n      \"if-let\", \"if-not\", \"if-some\", \"ifn?\", \"import\", \"in-ns\", \"inc\", \"inc'\",\n      \"indexed?\", \"init-proxy\", \"inst-ms\", \"inst-ms*\", \"inst?\", \"instance?\",\n      \"int\", \"int-array\", \"int?\", \"integer?\", \"interleave\", \"intern\",\n      \"interpose\", \"into\", \"into-array\", \"ints\", \"io!\", \"isa?\", \"iterate\",\n      \"iterator-seq\", \"juxt\", \"keep\", \"keep-indexed\", \"key\", \"keys\", \"keyword\",\n      \"keyword?\", \"last\", \"lazy-cat\", \"lazy-seq\", \"let\", \"letfn\", \"line-seq\",\n      \"list\", \"list*\", \"list?\", \"load\", \"load-file\", \"load-reader\",\n      \"load-string\", \"loaded-libs\", \"locking\", \"long\", \"long-array\", \"longs\",\n      \"loop\", \"macroexpand\", \"macroexpand-1\", \"make-array\", \"make-hierarchy\",\n      \"map\", \"map-entry?\", \"map-indexed\", \"map?\", \"mapcat\", \"mapv\", \"max\",\n      \"max-key\", \"memfn\", \"memoize\", \"merge\", \"merge-with\", \"meta\",\n      \"method-sig\", \"methods\", \"min\", \"min-key\", \"mix-collection-hash\", \"mod\",\n      \"munge\", \"name\", \"namespace\", \"namespace-munge\", \"nat-int?\", \"neg-int?\",\n      \"neg?\", \"newline\", \"next\", \"nfirst\", \"nil?\", \"nnext\", \"not\", \"not-any?\",\n      \"not-empty\", \"not-every?\", \"not=\", \"ns\", \"ns-aliases\", \"ns-imports\",\n      \"ns-interns\", \"ns-map\", \"ns-name\", \"ns-publics\", \"ns-refers\",\n      \"ns-resolve\", \"ns-unalias\", \"ns-unmap\", \"nth\", \"nthnext\", \"nthrest\",\n      \"num\", \"number?\", \"numerator\", \"object-array\", \"odd?\", \"or\", \"parents\",\n      \"partial\", \"partition\", \"partition-all\", \"partition-by\", \"pcalls\", \"peek\",\n      \"persistent!\", \"pmap\", \"pop\", \"pop!\", \"pop-thread-bindings\", \"pos-int?\",\n      \"pos?\", \"pr\", \"pr-str\", \"prefer-method\", \"prefers\",\n      \"primitives-classnames\", \"print\", \"print-ctor\", \"print-dup\",\n      \"print-method\", \"print-simple\", \"print-str\", \"printf\", \"println\",\n      \"println-str\", \"prn\", \"prn-str\", \"promise\", \"proxy\",\n      \"proxy-call-with-super\", \"proxy-mappings\", \"proxy-name\", \"proxy-super\",\n      \"push-thread-bindings\", \"pvalues\", \"qualified-ident?\",\n      \"qualified-keyword?\", \"qualified-symbol?\", \"quot\", \"rand\", \"rand-int\",\n      \"rand-nth\", \"random-sample\", \"range\", \"ratio?\", \"rational?\",\n      \"rationalize\", \"re-find\", \"re-groups\", \"re-matcher\", \"re-matches\",\n      \"re-pattern\", \"re-seq\", \"read\", \"read-line\", \"read-string\",\n      \"reader-conditional\", \"reader-conditional?\", \"realized?\", \"record?\",\n      \"reduce\", \"reduce-kv\", \"reduced\", \"reduced?\", \"reductions\", \"ref\",\n      \"ref-history-count\", \"ref-max-history\", \"ref-min-history\", \"ref-set\",\n      \"refer\", \"refer-clojure\", \"reify\", \"release-pending-sends\", \"rem\",\n      \"remove\", \"remove-all-methods\", \"remove-method\", \"remove-ns\",\n      \"remove-watch\", \"repeat\", \"repeatedly\", \"replace\", \"replicate\", \"require\",\n      \"reset!\", \"reset-meta!\", \"reset-vals!\", \"resolve\", \"rest\",\n      \"restart-agent\", \"resultset-seq\", \"reverse\", \"reversible?\", \"rseq\",\n      \"rsubseq\", \"run!\", \"satisfies?\", \"second\", \"select-keys\", \"send\",\n      \"send-off\", \"send-via\", \"seq\", \"seq?\", \"seqable?\", \"seque\", \"sequence\",\n      \"sequential?\", \"set\", \"set-agent-send-executor!\",\n      \"set-agent-send-off-executor!\", \"set-error-handler!\", \"set-error-mode!\",\n      \"set-validator!\", \"set?\", \"short\", \"short-array\", \"shorts\", \"shuffle\",\n      \"shutdown-agents\", \"simple-ident?\", \"simple-keyword?\", \"simple-symbol?\",\n      \"slurp\", \"some\", \"some->\", \"some->>\", \"some-fn\", \"some?\", \"sort\",\n      \"sort-by\", \"sorted-map\", \"sorted-map-by\", \"sorted-set\", \"sorted-set-by\",\n      \"sorted?\", \"special-symbol?\", \"spit\", \"split-at\", \"split-with\", \"str\",\n      \"string?\", \"struct\", \"struct-map\", \"subs\", \"subseq\", \"subvec\", \"supers\",\n      \"swap!\", \"swap-vals!\", \"symbol\", \"symbol?\", \"sync\", \"tagged-literal\",\n      \"tagged-literal?\", \"take\", \"take-last\", \"take-nth\", \"take-while\", \"test\",\n      \"the-ns\", \"thread-bound?\", \"time\", \"to-array\", \"to-array-2d\",\n      \"trampoline\", \"transduce\", \"transient\", \"tree-seq\", \"true?\", \"type\",\n      \"unchecked-add\", \"unchecked-add-int\", \"unchecked-byte\", \"unchecked-char\",\n      \"unchecked-dec\", \"unchecked-dec-int\", \"unchecked-divide-int\",\n      \"unchecked-double\", \"unchecked-float\", \"unchecked-inc\",\n      \"unchecked-inc-int\", \"unchecked-int\", \"unchecked-long\",\n      \"unchecked-multiply\", \"unchecked-multiply-int\", \"unchecked-negate\",\n      \"unchecked-negate-int\", \"unchecked-remainder-int\", \"unchecked-short\",\n      \"unchecked-subtract\", \"unchecked-subtract-int\", \"underive\", \"unquote\",\n      \"unquote-splicing\", \"unreduced\", \"unsigned-bit-shift-right\", \"update\",\n      \"update-in\", \"update-proxy\", \"uri?\", \"use\", \"uuid?\", \"val\", \"vals\",\n      \"var-get\", \"var-set\", \"var?\", \"vary-meta\", \"vec\", \"vector\", \"vector-of\",\n      \"vector?\", \"volatile!\", \"volatile?\", \"vreset!\", \"vswap!\", \"when\",\n      \"when-first\", \"when-let\", \"when-not\", \"when-some\", \"while\",\n      \"with-bindings\", \"with-bindings*\", \"with-in-str\", \"with-loading-context\",\n      \"with-local-vars\", \"with-meta\", \"with-open\", \"with-out-str\",\n      \"with-precision\", \"with-redefs\", \"with-redefs-fn\", \"xml-seq\", \"zero?\",\n      \"zipmap\"];\n  var haveBodyParameter = [\n      \"->\", \"->>\", \"as->\", \"binding\", \"bound-fn\", \"case\", \"catch\", \"comment\",\n      \"cond\", \"cond->\", \"cond->>\", \"condp\", \"def\", \"definterface\", \"defmethod\",\n      \"defn\", \"defmacro\", \"defprotocol\", \"defrecord\", \"defstruct\", \"deftype\",\n      \"do\", \"doseq\", \"dotimes\", \"doto\", \"extend\", \"extend-protocol\",\n      \"extend-type\", \"fn\", \"for\", \"future\", \"if\", \"if-let\", \"if-not\", \"if-some\",\n      \"let\", \"letfn\", \"locking\", \"loop\", \"ns\", \"proxy\", \"reify\", \"struct-map\",\n      \"some->\", \"some->>\", \"try\", \"when\", \"when-first\", \"when-let\", \"when-not\",\n      \"when-some\", \"while\", \"with-bindings\", \"with-bindings*\", \"with-in-str\",\n      \"with-loading-context\", \"with-local-vars\", \"with-meta\", \"with-open\",\n      \"with-out-str\", \"with-precision\", \"with-redefs\", \"with-redefs-fn\"];\n\n  CodeMirror.registerHelper(\"hintWords\", \"clojure\",\n    [].concat(atoms, specialForms, coreSymbols));\n\n  var atom = createLookupMap(atoms);\n  var specialForm = createLookupMap(specialForms);\n  var coreSymbol = createLookupMap(coreSymbols);\n  var hasBodyParameter = createLookupMap(haveBodyParameter);\n  var delimiter = /^(?:[\\\\\\[\\]\\s\"(),;@^`{}~]|$)/;\n  var numberLiteral = /^(?:[+\\-]?\\d+(?:(?:N|(?:[eE][+\\-]?\\d+))|(?:\\.?\\d*(?:M|(?:[eE][+\\-]?\\d+))?)|\\/\\d+|[xX][0-9a-fA-F]+|r[0-9a-zA-Z]+)?(?=[\\\\\\[\\]\\s\"#'(),;@^`{}~]|$))/;\n  var characterLiteral = /^(?:\\\\(?:backspace|formfeed|newline|return|space|tab|o[0-7]{3}|u[0-9A-Fa-f]{4}|x[0-9A-Fa-f]{4}|.)?(?=[\\\\\\[\\]\\s\"(),;@^`{}~]|$))/;\n\n  // simple-namespace := /^[^\\\\\\/\\[\\]\\d\\s\"#'(),;@^`{}~][^\\\\\\[\\]\\s\"(),;@^`{}~]*/\n  // simple-symbol    := /^(?:\\/|[^\\\\\\/\\[\\]\\d\\s\"#'(),;@^`{}~][^\\\\\\[\\]\\s\"(),;@^`{}~]*)/\n  // qualified-symbol := (<simple-namespace>(<.><simple-namespace>)*</>)?<simple-symbol>\n  var qualifiedSymbol = /^(?:(?:[^\\\\\\/\\[\\]\\d\\s\"#'(),;@^`{}~][^\\\\\\[\\]\\s\"(),;@^`{}~]*(?:\\.[^\\\\\\/\\[\\]\\d\\s\"#'(),;@^`{}~][^\\\\\\[\\]\\s\"(),;@^`{}~]*)*\\/)?(?:\\/|[^\\\\\\/\\[\\]\\d\\s\"#'(),;@^`{}~][^\\\\\\[\\]\\s\"(),;@^`{}~]*)*(?=[\\\\\\[\\]\\s\"(),;@^`{}~]|$))/;\n\n  function base(stream, state) {\n    if (stream.eatSpace() || stream.eat(\",\")) return [\"space\", null];\n    if (stream.match(numberLiteral)) return [null, \"number\"];\n    if (stream.match(characterLiteral)) return [null, \"string-2\"];\n    if (stream.eat(/^\"/)) return (state.tokenize = inString)(stream, state);\n    if (stream.eat(/^[(\\[{]/)) return [\"open\", \"bracket\"];\n    if (stream.eat(/^[)\\]}]/)) return [\"close\", \"bracket\"];\n    if (stream.eat(/^;/)) {stream.skipToEnd(); return [\"space\", \"comment\"];}\n    if (stream.eat(/^[#'@^`~]/)) return [null, \"meta\"];\n\n    var matches = stream.match(qualifiedSymbol);\n    var symbol = matches && matches[0];\n\n    if (!symbol) {\n      // advance stream by at least one character so we don't get stuck.\n      stream.next();\n      stream.eatWhile(function (c) {return !is(c, delimiter);});\n      return [null, \"error\"];\n    }\n\n    if (symbol === \"comment\" && state.lastToken === \"(\")\n      return (state.tokenize = inComment)(stream, state);\n    if (is(symbol, atom) || symbol.charAt(0) === \":\") return [\"symbol\", \"atom\"];\n    if (is(symbol, specialForm) || is(symbol, coreSymbol)) return [\"symbol\", \"keyword\"];\n    if (state.lastToken === \"(\") return [\"symbol\", \"builtin\"]; // other operator\n\n    return [\"symbol\", \"variable\"];\n  }\n\n  function inString(stream, state) {\n    var escaped = false, next;\n\n    while (next = stream.next()) {\n      if (next === \"\\\"\" && !escaped) {state.tokenize = base; break;}\n      escaped = !escaped && next === \"\\\\\";\n    }\n\n    return [null, \"string\"];\n  }\n\n  function inComment(stream, state) {\n    var parenthesisCount = 1;\n    var next;\n\n    while (next = stream.next()) {\n      if (next === \")\") parenthesisCount--;\n      if (next === \"(\") parenthesisCount++;\n      if (parenthesisCount === 0) {\n        stream.backUp(1);\n        state.tokenize = base;\n        break;\n      }\n    }\n\n    return [\"space\", \"comment\"];\n  }\n\n  function createLookupMap(words) {\n    var obj = {};\n\n    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n\n    return obj;\n  }\n\n  function is(value, test) {\n    if (test instanceof RegExp) return test.test(value);\n    if (test instanceof Object) return test.propertyIsEnumerable(value);\n  }\n\n  return {\n    startState: function () {\n      return {\n        ctx: {prev: null, start: 0, indentTo: 0},\n        lastToken: null,\n        tokenize: base\n      };\n    },\n\n    token: function (stream, state) {\n      if (stream.sol() && (typeof state.ctx.indentTo !== \"number\"))\n        state.ctx.indentTo = state.ctx.start + 1;\n\n      var typeStylePair = state.tokenize(stream, state);\n      var type = typeStylePair[0];\n      var style = typeStylePair[1];\n      var current = stream.current();\n\n      if (type !== \"space\") {\n        if (state.lastToken === \"(\" && state.ctx.indentTo === null) {\n          if (type === \"symbol\" && is(current, hasBodyParameter))\n            state.ctx.indentTo = state.ctx.start + options.indentUnit;\n          else state.ctx.indentTo = \"next\";\n        } else if (state.ctx.indentTo === \"next\") {\n          state.ctx.indentTo = stream.column();\n        }\n\n        state.lastToken = current;\n      }\n\n      if (type === \"open\")\n        state.ctx = {prev: state.ctx, start: stream.column(), indentTo: null};\n      else if (type === \"close\") state.ctx = state.ctx.prev || state.ctx;\n\n      return style;\n    },\n\n    indent: function (state) {\n      var i = state.ctx.indentTo;\n\n      return (typeof i === \"number\") ?\n        i :\n        state.ctx.start + 1;\n    },\n\n    closeBrackets: {pairs: \"()[]{}\\\"\\\"\"},\n    lineComment: \";;\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-clojure\", \"clojure\");\nCodeMirror.defineMIME(\"text/x-clojurescript\", \"clojure\");\nCodeMirror.defineMIME(\"application/edn\", \"clojure\");\n\n});\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$codemirror$lib$codemirror"]],"~:properties",["^5",["token","tokenize","lastToken","indent","start","prev","startState","indentTo","closeBrackets","pairs","ctx","lineComment"]],"~:compiled-at",1605286528088,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$codemirror$mode$clojure$clojure.js\",\n\"lineCount\":10,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/codemirror/mode/clojure/clojure.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$codemirror$mode$clojure$clojure\\\"] = function(global,require,module,exports) {\\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\\n// Distributed under an MIT license: https://codemirror.net/LICENSE\\n\\n(function(mod) {\\n  if (typeof exports === \\\"object\\\" && typeof module === \\\"object\\\") // CommonJS\\n    mod(require(\\\"../../lib/codemirror\\\"));\\n  else if (typeof define === \\\"function\\\" && define.amd) // AMD\\n    define([\\\"../../lib/codemirror\\\"], mod);\\n  else // Plain browser env\\n    mod(CodeMirror);\\n})(function(CodeMirror) {\\n\\\"use strict\\\";\\n\\nCodeMirror.defineMode(\\\"clojure\\\", function (options) {\\n  var atoms = [\\\"false\\\", \\\"nil\\\", \\\"true\\\"];\\n  var specialForms = [\\\".\\\", \\\"catch\\\", \\\"def\\\", \\\"do\\\", \\\"if\\\", \\\"monitor-enter\\\",\\n      \\\"monitor-exit\\\", \\\"new\\\", \\\"quote\\\", \\\"recur\\\", \\\"set!\\\", \\\"throw\\\", \\\"try\\\", \\\"var\\\"];\\n  var coreSymbols = [\\\"*\\\", \\\"*'\\\", \\\"*1\\\", \\\"*2\\\", \\\"*3\\\", \\\"*agent*\\\",\\n      \\\"*allow-unresolved-vars*\\\", \\\"*assert*\\\", \\\"*clojure-version*\\\",\\n      \\\"*command-line-args*\\\", \\\"*compile-files*\\\", \\\"*compile-path*\\\",\\n      \\\"*compiler-options*\\\", \\\"*data-readers*\\\", \\\"*default-data-reader-fn*\\\", \\\"*e\\\",\\n      \\\"*err*\\\", \\\"*file*\\\", \\\"*flush-on-newline*\\\", \\\"*fn-loader*\\\", \\\"*in*\\\",\\n      \\\"*math-context*\\\", \\\"*ns*\\\", \\\"*out*\\\", \\\"*print-dup*\\\", \\\"*print-length*\\\",\\n      \\\"*print-level*\\\", \\\"*print-meta*\\\", \\\"*print-namespace-maps*\\\",\\n      \\\"*print-readably*\\\", \\\"*read-eval*\\\", \\\"*reader-resolver*\\\", \\\"*source-path*\\\",\\n      \\\"*suppress-read*\\\", \\\"*unchecked-math*\\\", \\\"*use-context-classloader*\\\",\\n      \\\"*verbose-defrecords*\\\", \\\"*warn-on-reflection*\\\", \\\"+\\\", \\\"+'\\\", \\\"-\\\", \\\"-'\\\",\\n      \\\"->\\\", \\\"->>\\\", \\\"->ArrayChunk\\\", \\\"->Eduction\\\", \\\"->Vec\\\", \\\"->VecNode\\\",\\n      \\\"->VecSeq\\\", \\\"-cache-protocol-fn\\\", \\\"-reset-methods\\\", \\\"..\\\", \\\"/\\\", \\\"<\\\", \\\"<=\\\",\\n      \\\"=\\\", \\\"==\\\", \\\">\\\", \\\">=\\\", \\\"EMPTY-NODE\\\", \\\"Inst\\\", \\\"StackTraceElement->vec\\\",\\n      \\\"Throwable->map\\\", \\\"accessor\\\", \\\"aclone\\\", \\\"add-classpath\\\", \\\"add-watch\\\",\\n      \\\"agent\\\", \\\"agent-error\\\", \\\"agent-errors\\\", \\\"aget\\\", \\\"alength\\\", \\\"alias\\\",\\n      \\\"all-ns\\\", \\\"alter\\\", \\\"alter-meta!\\\", \\\"alter-var-root\\\", \\\"amap\\\", \\\"ancestors\\\",\\n      \\\"and\\\", \\\"any?\\\", \\\"apply\\\", \\\"areduce\\\", \\\"array-map\\\", \\\"as->\\\", \\\"aset\\\",\\n      \\\"aset-boolean\\\", \\\"aset-byte\\\", \\\"aset-char\\\", \\\"aset-double\\\", \\\"aset-float\\\",\\n      \\\"aset-int\\\", \\\"aset-long\\\", \\\"aset-short\\\", \\\"assert\\\", \\\"assoc\\\", \\\"assoc!\\\",\\n      \\\"assoc-in\\\", \\\"associative?\\\", \\\"atom\\\", \\\"await\\\", \\\"await-for\\\", \\\"await1\\\",\\n      \\\"bases\\\", \\\"bean\\\", \\\"bigdec\\\", \\\"bigint\\\", \\\"biginteger\\\", \\\"binding\\\", \\\"bit-and\\\",\\n      \\\"bit-and-not\\\", \\\"bit-clear\\\", \\\"bit-flip\\\", \\\"bit-not\\\", \\\"bit-or\\\", \\\"bit-set\\\",\\n      \\\"bit-shift-left\\\", \\\"bit-shift-right\\\", \\\"bit-test\\\", \\\"bit-xor\\\", \\\"boolean\\\",\\n      \\\"boolean-array\\\", \\\"boolean?\\\", \\\"booleans\\\", \\\"bound-fn\\\", \\\"bound-fn*\\\",\\n      \\\"bound?\\\", \\\"bounded-count\\\", \\\"butlast\\\", \\\"byte\\\", \\\"byte-array\\\", \\\"bytes\\\",\\n      \\\"bytes?\\\", \\\"case\\\", \\\"cast\\\", \\\"cat\\\", \\\"char\\\", \\\"char-array\\\",\\n      \\\"char-escape-string\\\", \\\"char-name-string\\\", \\\"char?\\\", \\\"chars\\\", \\\"chunk\\\",\\n      \\\"chunk-append\\\", \\\"chunk-buffer\\\", \\\"chunk-cons\\\", \\\"chunk-first\\\", \\\"chunk-next\\\",\\n      \\\"chunk-rest\\\", \\\"chunked-seq?\\\", \\\"class\\\", \\\"class?\\\", \\\"clear-agent-errors\\\",\\n      \\\"clojure-version\\\", \\\"coll?\\\", \\\"comment\\\", \\\"commute\\\", \\\"comp\\\", \\\"comparator\\\",\\n      \\\"compare\\\", \\\"compare-and-set!\\\", \\\"compile\\\", \\\"complement\\\", \\\"completing\\\",\\n      \\\"concat\\\", \\\"cond\\\", \\\"cond->\\\", \\\"cond->>\\\", \\\"condp\\\", \\\"conj\\\", \\\"conj!\\\", \\\"cons\\\",\\n      \\\"constantly\\\", \\\"construct-proxy\\\", \\\"contains?\\\", \\\"count\\\", \\\"counted?\\\",\\n      \\\"create-ns\\\", \\\"create-struct\\\", \\\"cycle\\\", \\\"dec\\\", \\\"dec'\\\", \\\"decimal?\\\",\\n      \\\"declare\\\", \\\"dedupe\\\", \\\"default-data-readers\\\", \\\"definline\\\", \\\"definterface\\\",\\n      \\\"defmacro\\\", \\\"defmethod\\\", \\\"defmulti\\\", \\\"defn\\\", \\\"defn-\\\", \\\"defonce\\\",\\n      \\\"defprotocol\\\", \\\"defrecord\\\", \\\"defstruct\\\", \\\"deftype\\\", \\\"delay\\\", \\\"delay?\\\",\\n      \\\"deliver\\\", \\\"denominator\\\", \\\"deref\\\", \\\"derive\\\", \\\"descendants\\\", \\\"destructure\\\",\\n      \\\"disj\\\", \\\"disj!\\\", \\\"dissoc\\\", \\\"dissoc!\\\", \\\"distinct\\\", \\\"distinct?\\\", \\\"doall\\\",\\n      \\\"dorun\\\", \\\"doseq\\\", \\\"dosync\\\", \\\"dotimes\\\", \\\"doto\\\", \\\"double\\\", \\\"double-array\\\",\\n      \\\"double?\\\", \\\"doubles\\\", \\\"drop\\\", \\\"drop-last\\\", \\\"drop-while\\\", \\\"eduction\\\",\\n      \\\"empty\\\", \\\"empty?\\\", \\\"ensure\\\", \\\"ensure-reduced\\\", \\\"enumeration-seq\\\",\\n      \\\"error-handler\\\", \\\"error-mode\\\", \\\"eval\\\", \\\"even?\\\", \\\"every-pred\\\", \\\"every?\\\",\\n      \\\"ex-data\\\", \\\"ex-info\\\", \\\"extend\\\", \\\"extend-protocol\\\", \\\"extend-type\\\",\\n      \\\"extenders\\\", \\\"extends?\\\", \\\"false?\\\", \\\"ffirst\\\", \\\"file-seq\\\", \\\"filter\\\",\\n      \\\"filterv\\\", \\\"find\\\", \\\"find-keyword\\\", \\\"find-ns\\\", \\\"find-protocol-impl\\\",\\n      \\\"find-protocol-method\\\", \\\"find-var\\\", \\\"first\\\", \\\"flatten\\\", \\\"float\\\",\\n      \\\"float-array\\\", \\\"float?\\\", \\\"floats\\\", \\\"flush\\\", \\\"fn\\\", \\\"fn?\\\", \\\"fnext\\\", \\\"fnil\\\",\\n      \\\"for\\\", \\\"force\\\", \\\"format\\\", \\\"frequencies\\\", \\\"future\\\", \\\"future-call\\\",\\n      \\\"future-cancel\\\", \\\"future-cancelled?\\\", \\\"future-done?\\\", \\\"future?\\\",\\n      \\\"gen-class\\\", \\\"gen-interface\\\", \\\"gensym\\\", \\\"get\\\", \\\"get-in\\\", \\\"get-method\\\",\\n      \\\"get-proxy-class\\\", \\\"get-thread-bindings\\\", \\\"get-validator\\\", \\\"group-by\\\",\\n      \\\"halt-when\\\", \\\"hash\\\", \\\"hash-combine\\\", \\\"hash-map\\\", \\\"hash-ordered-coll\\\",\\n      \\\"hash-set\\\", \\\"hash-unordered-coll\\\", \\\"ident?\\\", \\\"identical?\\\", \\\"identity\\\",\\n      \\\"if-let\\\", \\\"if-not\\\", \\\"if-some\\\", \\\"ifn?\\\", \\\"import\\\", \\\"in-ns\\\", \\\"inc\\\", \\\"inc'\\\",\\n      \\\"indexed?\\\", \\\"init-proxy\\\", \\\"inst-ms\\\", \\\"inst-ms*\\\", \\\"inst?\\\", \\\"instance?\\\",\\n      \\\"int\\\", \\\"int-array\\\", \\\"int?\\\", \\\"integer?\\\", \\\"interleave\\\", \\\"intern\\\",\\n      \\\"interpose\\\", \\\"into\\\", \\\"into-array\\\", \\\"ints\\\", \\\"io!\\\", \\\"isa?\\\", \\\"iterate\\\",\\n      \\\"iterator-seq\\\", \\\"juxt\\\", \\\"keep\\\", \\\"keep-indexed\\\", \\\"key\\\", \\\"keys\\\", \\\"keyword\\\",\\n      \\\"keyword?\\\", \\\"last\\\", \\\"lazy-cat\\\", \\\"lazy-seq\\\", \\\"let\\\", \\\"letfn\\\", \\\"line-seq\\\",\\n      \\\"list\\\", \\\"list*\\\", \\\"list?\\\", \\\"load\\\", \\\"load-file\\\", \\\"load-reader\\\",\\n      \\\"load-string\\\", \\\"loaded-libs\\\", \\\"locking\\\", \\\"long\\\", \\\"long-array\\\", \\\"longs\\\",\\n      \\\"loop\\\", \\\"macroexpand\\\", \\\"macroexpand-1\\\", \\\"make-array\\\", \\\"make-hierarchy\\\",\\n      \\\"map\\\", \\\"map-entry?\\\", \\\"map-indexed\\\", \\\"map?\\\", \\\"mapcat\\\", \\\"mapv\\\", \\\"max\\\",\\n      \\\"max-key\\\", \\\"memfn\\\", \\\"memoize\\\", \\\"merge\\\", \\\"merge-with\\\", \\\"meta\\\",\\n      \\\"method-sig\\\", \\\"methods\\\", \\\"min\\\", \\\"min-key\\\", \\\"mix-collection-hash\\\", \\\"mod\\\",\\n      \\\"munge\\\", \\\"name\\\", \\\"namespace\\\", \\\"namespace-munge\\\", \\\"nat-int?\\\", \\\"neg-int?\\\",\\n      \\\"neg?\\\", \\\"newline\\\", \\\"next\\\", \\\"nfirst\\\", \\\"nil?\\\", \\\"nnext\\\", \\\"not\\\", \\\"not-any?\\\",\\n      \\\"not-empty\\\", \\\"not-every?\\\", \\\"not=\\\", \\\"ns\\\", \\\"ns-aliases\\\", \\\"ns-imports\\\",\\n      \\\"ns-interns\\\", \\\"ns-map\\\", \\\"ns-name\\\", \\\"ns-publics\\\", \\\"ns-refers\\\",\\n      \\\"ns-resolve\\\", \\\"ns-unalias\\\", \\\"ns-unmap\\\", \\\"nth\\\", \\\"nthnext\\\", \\\"nthrest\\\",\\n      \\\"num\\\", \\\"number?\\\", \\\"numerator\\\", \\\"object-array\\\", \\\"odd?\\\", \\\"or\\\", \\\"parents\\\",\\n      \\\"partial\\\", \\\"partition\\\", \\\"partition-all\\\", \\\"partition-by\\\", \\\"pcalls\\\", \\\"peek\\\",\\n      \\\"persistent!\\\", \\\"pmap\\\", \\\"pop\\\", \\\"pop!\\\", \\\"pop-thread-bindings\\\", \\\"pos-int?\\\",\\n      \\\"pos?\\\", \\\"pr\\\", \\\"pr-str\\\", \\\"prefer-method\\\", \\\"prefers\\\",\\n      \\\"primitives-classnames\\\", \\\"print\\\", \\\"print-ctor\\\", \\\"print-dup\\\",\\n      \\\"print-method\\\", \\\"print-simple\\\", \\\"print-str\\\", \\\"printf\\\", \\\"println\\\",\\n      \\\"println-str\\\", \\\"prn\\\", \\\"prn-str\\\", \\\"promise\\\", \\\"proxy\\\",\\n      \\\"proxy-call-with-super\\\", \\\"proxy-mappings\\\", \\\"proxy-name\\\", \\\"proxy-super\\\",\\n      \\\"push-thread-bindings\\\", \\\"pvalues\\\", \\\"qualified-ident?\\\",\\n      \\\"qualified-keyword?\\\", \\\"qualified-symbol?\\\", \\\"quot\\\", \\\"rand\\\", \\\"rand-int\\\",\\n      \\\"rand-nth\\\", \\\"random-sample\\\", \\\"range\\\", \\\"ratio?\\\", \\\"rational?\\\",\\n      \\\"rationalize\\\", \\\"re-find\\\", \\\"re-groups\\\", \\\"re-matcher\\\", \\\"re-matches\\\",\\n      \\\"re-pattern\\\", \\\"re-seq\\\", \\\"read\\\", \\\"read-line\\\", \\\"read-string\\\",\\n      \\\"reader-conditional\\\", \\\"reader-conditional?\\\", \\\"realized?\\\", \\\"record?\\\",\\n      \\\"reduce\\\", \\\"reduce-kv\\\", \\\"reduced\\\", \\\"reduced?\\\", \\\"reductions\\\", \\\"ref\\\",\\n      \\\"ref-history-count\\\", \\\"ref-max-history\\\", \\\"ref-min-history\\\", \\\"ref-set\\\",\\n      \\\"refer\\\", \\\"refer-clojure\\\", \\\"reify\\\", \\\"release-pending-sends\\\", \\\"rem\\\",\\n      \\\"remove\\\", \\\"remove-all-methods\\\", \\\"remove-method\\\", \\\"remove-ns\\\",\\n      \\\"remove-watch\\\", \\\"repeat\\\", \\\"repeatedly\\\", \\\"replace\\\", \\\"replicate\\\", \\\"require\\\",\\n      \\\"reset!\\\", \\\"reset-meta!\\\", \\\"reset-vals!\\\", \\\"resolve\\\", \\\"rest\\\",\\n      \\\"restart-agent\\\", \\\"resultset-seq\\\", \\\"reverse\\\", \\\"reversible?\\\", \\\"rseq\\\",\\n      \\\"rsubseq\\\", \\\"run!\\\", \\\"satisfies?\\\", \\\"second\\\", \\\"select-keys\\\", \\\"send\\\",\\n      \\\"send-off\\\", \\\"send-via\\\", \\\"seq\\\", \\\"seq?\\\", \\\"seqable?\\\", \\\"seque\\\", \\\"sequence\\\",\\n      \\\"sequential?\\\", \\\"set\\\", \\\"set-agent-send-executor!\\\",\\n      \\\"set-agent-send-off-executor!\\\", \\\"set-error-handler!\\\", \\\"set-error-mode!\\\",\\n      \\\"set-validator!\\\", \\\"set?\\\", \\\"short\\\", \\\"short-array\\\", \\\"shorts\\\", \\\"shuffle\\\",\\n      \\\"shutdown-agents\\\", \\\"simple-ident?\\\", \\\"simple-keyword?\\\", \\\"simple-symbol?\\\",\\n      \\\"slurp\\\", \\\"some\\\", \\\"some->\\\", \\\"some->>\\\", \\\"some-fn\\\", \\\"some?\\\", \\\"sort\\\",\\n      \\\"sort-by\\\", \\\"sorted-map\\\", \\\"sorted-map-by\\\", \\\"sorted-set\\\", \\\"sorted-set-by\\\",\\n      \\\"sorted?\\\", \\\"special-symbol?\\\", \\\"spit\\\", \\\"split-at\\\", \\\"split-with\\\", \\\"str\\\",\\n      \\\"string?\\\", \\\"struct\\\", \\\"struct-map\\\", \\\"subs\\\", \\\"subseq\\\", \\\"subvec\\\", \\\"supers\\\",\\n      \\\"swap!\\\", \\\"swap-vals!\\\", \\\"symbol\\\", \\\"symbol?\\\", \\\"sync\\\", \\\"tagged-literal\\\",\\n      \\\"tagged-literal?\\\", \\\"take\\\", \\\"take-last\\\", \\\"take-nth\\\", \\\"take-while\\\", \\\"test\\\",\\n      \\\"the-ns\\\", \\\"thread-bound?\\\", \\\"time\\\", \\\"to-array\\\", \\\"to-array-2d\\\",\\n      \\\"trampoline\\\", \\\"transduce\\\", \\\"transient\\\", \\\"tree-seq\\\", \\\"true?\\\", \\\"type\\\",\\n      \\\"unchecked-add\\\", \\\"unchecked-add-int\\\", \\\"unchecked-byte\\\", \\\"unchecked-char\\\",\\n      \\\"unchecked-dec\\\", \\\"unchecked-dec-int\\\", \\\"unchecked-divide-int\\\",\\n      \\\"unchecked-double\\\", \\\"unchecked-float\\\", \\\"unchecked-inc\\\",\\n      \\\"unchecked-inc-int\\\", \\\"unchecked-int\\\", \\\"unchecked-long\\\",\\n      \\\"unchecked-multiply\\\", \\\"unchecked-multiply-int\\\", \\\"unchecked-negate\\\",\\n      \\\"unchecked-negate-int\\\", \\\"unchecked-remainder-int\\\", \\\"unchecked-short\\\",\\n      \\\"unchecked-subtract\\\", \\\"unchecked-subtract-int\\\", \\\"underive\\\", \\\"unquote\\\",\\n      \\\"unquote-splicing\\\", \\\"unreduced\\\", \\\"unsigned-bit-shift-right\\\", \\\"update\\\",\\n      \\\"update-in\\\", \\\"update-proxy\\\", \\\"uri?\\\", \\\"use\\\", \\\"uuid?\\\", \\\"val\\\", \\\"vals\\\",\\n      \\\"var-get\\\", \\\"var-set\\\", \\\"var?\\\", \\\"vary-meta\\\", \\\"vec\\\", \\\"vector\\\", \\\"vector-of\\\",\\n      \\\"vector?\\\", \\\"volatile!\\\", \\\"volatile?\\\", \\\"vreset!\\\", \\\"vswap!\\\", \\\"when\\\",\\n      \\\"when-first\\\", \\\"when-let\\\", \\\"when-not\\\", \\\"when-some\\\", \\\"while\\\",\\n      \\\"with-bindings\\\", \\\"with-bindings*\\\", \\\"with-in-str\\\", \\\"with-loading-context\\\",\\n      \\\"with-local-vars\\\", \\\"with-meta\\\", \\\"with-open\\\", \\\"with-out-str\\\",\\n      \\\"with-precision\\\", \\\"with-redefs\\\", \\\"with-redefs-fn\\\", \\\"xml-seq\\\", \\\"zero?\\\",\\n      \\\"zipmap\\\"];\\n  var haveBodyParameter = [\\n      \\\"->\\\", \\\"->>\\\", \\\"as->\\\", \\\"binding\\\", \\\"bound-fn\\\", \\\"case\\\", \\\"catch\\\", \\\"comment\\\",\\n      \\\"cond\\\", \\\"cond->\\\", \\\"cond->>\\\", \\\"condp\\\", \\\"def\\\", \\\"definterface\\\", \\\"defmethod\\\",\\n      \\\"defn\\\", \\\"defmacro\\\", \\\"defprotocol\\\", \\\"defrecord\\\", \\\"defstruct\\\", \\\"deftype\\\",\\n      \\\"do\\\", \\\"doseq\\\", \\\"dotimes\\\", \\\"doto\\\", \\\"extend\\\", \\\"extend-protocol\\\",\\n      \\\"extend-type\\\", \\\"fn\\\", \\\"for\\\", \\\"future\\\", \\\"if\\\", \\\"if-let\\\", \\\"if-not\\\", \\\"if-some\\\",\\n      \\\"let\\\", \\\"letfn\\\", \\\"locking\\\", \\\"loop\\\", \\\"ns\\\", \\\"proxy\\\", \\\"reify\\\", \\\"struct-map\\\",\\n      \\\"some->\\\", \\\"some->>\\\", \\\"try\\\", \\\"when\\\", \\\"when-first\\\", \\\"when-let\\\", \\\"when-not\\\",\\n      \\\"when-some\\\", \\\"while\\\", \\\"with-bindings\\\", \\\"with-bindings*\\\", \\\"with-in-str\\\",\\n      \\\"with-loading-context\\\", \\\"with-local-vars\\\", \\\"with-meta\\\", \\\"with-open\\\",\\n      \\\"with-out-str\\\", \\\"with-precision\\\", \\\"with-redefs\\\", \\\"with-redefs-fn\\\"];\\n\\n  CodeMirror.registerHelper(\\\"hintWords\\\", \\\"clojure\\\",\\n    [].concat(atoms, specialForms, coreSymbols));\\n\\n  var atom = createLookupMap(atoms);\\n  var specialForm = createLookupMap(specialForms);\\n  var coreSymbol = createLookupMap(coreSymbols);\\n  var hasBodyParameter = createLookupMap(haveBodyParameter);\\n  var delimiter = /^(?:[\\\\\\\\\\\\[\\\\]\\\\s\\\"(),;@^`{}~]|$)/;\\n  var numberLiteral = /^(?:[+\\\\-]?\\\\d+(?:(?:N|(?:[eE][+\\\\-]?\\\\d+))|(?:\\\\.?\\\\d*(?:M|(?:[eE][+\\\\-]?\\\\d+))?)|\\\\/\\\\d+|[xX][0-9a-fA-F]+|r[0-9a-zA-Z]+)?(?=[\\\\\\\\\\\\[\\\\]\\\\s\\\"#'(),;@^`{}~]|$))/;\\n  var characterLiteral = /^(?:\\\\\\\\(?:backspace|formfeed|newline|return|space|tab|o[0-7]{3}|u[0-9A-Fa-f]{4}|x[0-9A-Fa-f]{4}|.)?(?=[\\\\\\\\\\\\[\\\\]\\\\s\\\"(),;@^`{}~]|$))/;\\n\\n  // simple-namespace := /^[^\\\\\\\\\\\\/\\\\[\\\\]\\\\d\\\\s\\\"#'(),;@^`{}~][^\\\\\\\\\\\\[\\\\]\\\\s\\\"(),;@^`{}~]*/\\n  // simple-symbol    := /^(?:\\\\/|[^\\\\\\\\\\\\/\\\\[\\\\]\\\\d\\\\s\\\"#'(),;@^`{}~][^\\\\\\\\\\\\[\\\\]\\\\s\\\"(),;@^`{}~]*)/\\n  // qualified-symbol := (<simple-namespace>(<.><simple-namespace>)*</>)?<simple-symbol>\\n  var qualifiedSymbol = /^(?:(?:[^\\\\\\\\\\\\/\\\\[\\\\]\\\\d\\\\s\\\"#'(),;@^`{}~][^\\\\\\\\\\\\[\\\\]\\\\s\\\"(),;@^`{}~]*(?:\\\\.[^\\\\\\\\\\\\/\\\\[\\\\]\\\\d\\\\s\\\"#'(),;@^`{}~][^\\\\\\\\\\\\[\\\\]\\\\s\\\"(),;@^`{}~]*)*\\\\/)?(?:\\\\/|[^\\\\\\\\\\\\/\\\\[\\\\]\\\\d\\\\s\\\"#'(),;@^`{}~][^\\\\\\\\\\\\[\\\\]\\\\s\\\"(),;@^`{}~]*)*(?=[\\\\\\\\\\\\[\\\\]\\\\s\\\"(),;@^`{}~]|$))/;\\n\\n  function base(stream, state) {\\n    if (stream.eatSpace() || stream.eat(\\\",\\\")) return [\\\"space\\\", null];\\n    if (stream.match(numberLiteral)) return [null, \\\"number\\\"];\\n    if (stream.match(characterLiteral)) return [null, \\\"string-2\\\"];\\n    if (stream.eat(/^\\\"/)) return (state.tokenize = inString)(stream, state);\\n    if (stream.eat(/^[(\\\\[{]/)) return [\\\"open\\\", \\\"bracket\\\"];\\n    if (stream.eat(/^[)\\\\]}]/)) return [\\\"close\\\", \\\"bracket\\\"];\\n    if (stream.eat(/^;/)) {stream.skipToEnd(); return [\\\"space\\\", \\\"comment\\\"];}\\n    if (stream.eat(/^[#'@^`~]/)) return [null, \\\"meta\\\"];\\n\\n    var matches = stream.match(qualifiedSymbol);\\n    var symbol = matches && matches[0];\\n\\n    if (!symbol) {\\n      // advance stream by at least one character so we don't get stuck.\\n      stream.next();\\n      stream.eatWhile(function (c) {return !is(c, delimiter);});\\n      return [null, \\\"error\\\"];\\n    }\\n\\n    if (symbol === \\\"comment\\\" && state.lastToken === \\\"(\\\")\\n      return (state.tokenize = inComment)(stream, state);\\n    if (is(symbol, atom) || symbol.charAt(0) === \\\":\\\") return [\\\"symbol\\\", \\\"atom\\\"];\\n    if (is(symbol, specialForm) || is(symbol, coreSymbol)) return [\\\"symbol\\\", \\\"keyword\\\"];\\n    if (state.lastToken === \\\"(\\\") return [\\\"symbol\\\", \\\"builtin\\\"]; // other operator\\n\\n    return [\\\"symbol\\\", \\\"variable\\\"];\\n  }\\n\\n  function inString(stream, state) {\\n    var escaped = false, next;\\n\\n    while (next = stream.next()) {\\n      if (next === \\\"\\\\\\\"\\\" && !escaped) {state.tokenize = base; break;}\\n      escaped = !escaped && next === \\\"\\\\\\\\\\\";\\n    }\\n\\n    return [null, \\\"string\\\"];\\n  }\\n\\n  function inComment(stream, state) {\\n    var parenthesisCount = 1;\\n    var next;\\n\\n    while (next = stream.next()) {\\n      if (next === \\\")\\\") parenthesisCount--;\\n      if (next === \\\"(\\\") parenthesisCount++;\\n      if (parenthesisCount === 0) {\\n        stream.backUp(1);\\n        state.tokenize = base;\\n        break;\\n      }\\n    }\\n\\n    return [\\\"space\\\", \\\"comment\\\"];\\n  }\\n\\n  function createLookupMap(words) {\\n    var obj = {};\\n\\n    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\\n\\n    return obj;\\n  }\\n\\n  function is(value, test) {\\n    if (test instanceof RegExp) return test.test(value);\\n    if (test instanceof Object) return test.propertyIsEnumerable(value);\\n  }\\n\\n  return {\\n    startState: function () {\\n      return {\\n        ctx: {prev: null, start: 0, indentTo: 0},\\n        lastToken: null,\\n        tokenize: base\\n      };\\n    },\\n\\n    token: function (stream, state) {\\n      if (stream.sol() && (typeof state.ctx.indentTo !== \\\"number\\\"))\\n        state.ctx.indentTo = state.ctx.start + 1;\\n\\n      var typeStylePair = state.tokenize(stream, state);\\n      var type = typeStylePair[0];\\n      var style = typeStylePair[1];\\n      var current = stream.current();\\n\\n      if (type !== \\\"space\\\") {\\n        if (state.lastToken === \\\"(\\\" && state.ctx.indentTo === null) {\\n          if (type === \\\"symbol\\\" && is(current, hasBodyParameter))\\n            state.ctx.indentTo = state.ctx.start + options.indentUnit;\\n          else state.ctx.indentTo = \\\"next\\\";\\n        } else if (state.ctx.indentTo === \\\"next\\\") {\\n          state.ctx.indentTo = stream.column();\\n        }\\n\\n        state.lastToken = current;\\n      }\\n\\n      if (type === \\\"open\\\")\\n        state.ctx = {prev: state.ctx, start: stream.column(), indentTo: null};\\n      else if (type === \\\"close\\\") state.ctx = state.ctx.prev || state.ctx;\\n\\n      return style;\\n    },\\n\\n    indent: function (state) {\\n      var i = state.ctx.indentTo;\\n\\n      return (typeof i === \\\"number\\\") ?\\n        i :\\n        state.ctx.start + 1;\\n    },\\n\\n    closeBrackets: {pairs: \\\"()[]{}\\\\\\\"\\\\\\\"\\\"},\\n    lineComment: \\\";;\\\"\\n  };\\n});\\n\\nCodeMirror.defineMIME(\\\"text/x-clojure\\\", \\\"clojure\\\");\\nCodeMirror.defineMIME(\\\"text/x-clojurescript\\\", \\\"clojure\\\");\\nCodeMirror.defineMIME(\\\"application/edn\\\", \\\"clojure\\\");\\n\\n});\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"mod\",\"define\",\"amd\",\"CodeMirror\",\"defineMode\",\"options\",\"base\",\"stream\",\"state\",\"eatSpace\",\"eat\",\"match\",\"numberLiteral\",\"characterLiteral\",\"tokenize\",\"inString\",\"skipToEnd\",\"matches\",\"qualifiedSymbol\",\"symbol\",\"lastToken\",\"inComment\",\"is\",\"atom\",\"charAt\",\"specialForm\",\"coreSymbol\",\"next\",\"eatWhile\",\"c\",\"delimiter\",\"escaped\",\"parenthesisCount\",\"backUp\",\"createLookupMap\",\"words\",\"obj\",\"i\",\"length\",\"value\",\"test\",\"RegExp\",\"Object\",\"propertyIsEnumerable\",\"atoms\",\"specialForms\",\"coreSymbols\",\"registerHelper\",\"concat\",\"hasBodyParameter\",\"haveBodyParameter\",\"startState\",\"ctx\",\"prev\",\"start\",\"indentTo\",\"token\",\"sol\",\"typeStylePair\",\"type\",\"style\",\"current\",\"indentUnit\",\"column\",\"indent\",\"closeBrackets\",\"pairs\",\"lineComment\",\"defineMIME\"]\n}\n"]